import{vec2 as U,vec3 as V,vec4 as w}from"gl-matrix";import{OctreeCSG as I,MaterialAttributeStandardType as x,Polygon as N,Vertex as k,MaterialAttributeValueType as C,MaterialAttributeTransform as v}from"octreecsg-ea";function A(t,i,o){let s;if(o){s=[];for(let[a,e]of o)s.push(a.get(t,e()))}return new k(i.get(t,V.create()),s)}function O(t,i){let o=t.indexData,s=o===null?t.vertexCount:o.length;if(s%3!==0)throw new Error(`Mesh has an invalid vertex count (${s}). Must be a multiple of 3`);let a=t.attribute(WL.MeshAttribute.Position),e=[],n=[],f=t.attribute(WL.MeshAttribute.Tangent);f&&(e.push([f,()=>w.create()]),n.push({type:x.Tangent,valueType:C.Vec4,transformable:v.Model,flippable:!1}));let l=t.attribute(WL.MeshAttribute.Normal);l&&(e.push([l,()=>V.create()]),n.push({type:x.Normal,valueType:C.Vec3,transformable:v.Normal,flippable:!0}));let M=t.attribute(WL.MeshAttribute.TextureCoordinate);M&&(e.push([M,()=>U.create()]),n.push({type:x.TextureCoordinate,valueType:C.Vec2,transformable:null,flippable:!1}));let d=t.attribute(WL.MeshAttribute.Color);d&&(e.push([d,()=>w.create()]),n.push({type:x.Color,valueType:C.Vec3,transformable:null,flippable:!1})),e.length||(e=null);let b=i!=null?i:0,m=new I(new Map([[b,n]]));for(let u=0;u<s;){let p,h,y;if(o===null)p=A(u++,a,e),h=A(u++,a,e),y=A(u++,a,e);else{let g=o[u++],c=o[u++],G=o[u++];p=A(g,a,e),h=A(c,a,e),y=A(G,a,e)}let r=new N([p,h,y],b);r.originalValid=!0,m.addPolygon(r)}return m}import{MaterialAttributeStandardType as T}from"octreecsg-ea";function W(t,i,o,s){if(o.set(i,t.pos),t.extra){let a=t.extra.length;for(let e=0;e<a;e++){let n=s.get(e);n&&n.set(i,t.extra[e])}}}function L(t,i){var e;let o=t.getPolygons(),s=new Map;for(let n of o){let f=n.shared;if(!i.has(f))continue;let l=(e=s.get(f))!=null?e:0;s.set(f,l+1)}let a=new Map;for(let[n,f]of s){let l=f*3,M,d;l<=255?(M=WL.MeshIndexType.UnsignedByte,d=new Uint8Array(l)):l<=65535?(M=WL.MeshIndexType.UnsignedShort,d=new Uint16Array(l)):(M=WL.MeshIndexType.UnsignedInt,d=new Uint32Array(l));for(let r=0;r<l;r++)d[r]=r;let b=new WL.Mesh({vertexCount:l,indexType:M,indexData:d}),m=i.get(n),u=b.attribute(WL.MeshAttribute.Position),p=new Map,h=t.materials.get(n);if(h)for(let[r,g]of h.entries())switch(g.type){case T.Tangent:{let c=b.attribute(WL.MeshAttribute.Tangent);c?p.set(r,c):console.warn("Could not create tangent mesh attribute accessor. Vertex property ignored");break}case T.Normal:{let c=b.attribute(WL.MeshAttribute.Normal);c?p.set(r,c):console.warn("Could not create normal mesh attribute accessor. Vertex property ignored");break}case T.TextureCoordinate:{let c=b.attribute(WL.MeshAttribute.TextureCoordinate);c?p.set(r,c):console.warn("Could not create texture coordinate mesh attribute accessor. Vertex property ignored");break}case T.Color:{let c=b.attribute(WL.MeshAttribute.Color);c?p.set(r,c):console.warn("Could not create color mesh attribute accessor. Vertex property ignored");break}default:console.warn(`Unsupported mesh attribute ID (${g}) ignored`)}let y=0;for(let r of o)r.shared===n&&(W(r.vertices[0],y++,u,p),W(r.vertices[1],y++,u,p),W(r.vertices[2],y++,u,p));a.set(m,b)}return a}function S(t,i,o){let s=L(i,o);for(let[a,e]of s.entries())t.addComponent("mesh",{material:a,mesh:e})}export{S as wleAddOctreeCSGToObject,O as wleMeshToOctreeCSG,L as wleOctreeCSGToMesh};
//# sourceMappingURL=OctreeCSG-ea-wle.esm.min.js.map
