{
  "version": 3,
  "sources": ["../src/conversion/mesh-to-octree.ts", "../src/conversion/octree-to-mesh.ts", "../src/conversion/add-octree-to-object.ts"],
  "sourcesContent": ["// eslint-disable-next-line @typescript-eslint/triple-slash-reference\n/// <reference path=\"../../types/globals.d.ts\" />\n\nimport { vec2, vec3, vec4 } from 'gl-matrix';\nimport { OctreeCSG, MaterialAttributeStandardType, Polygon, Vertex, MaterialAttributeValueType, MaterialAttributeTransform } from 'octreecsg-ea';\n\nimport type { MaterialAttribute } from 'octreecsg-ea';\n\ntype AttributeAccessors = Array<[accessor: WL.MeshAttributeAccessor, vecFactory: () => Array<number> | Float32Array]> | null;\n\nfunction makeVertex(index: number, posAccessor: WL.MeshAttributeAccessor, attributeAccessors: AttributeAccessors): Vertex {\n    let extra = undefined;\n    if (attributeAccessors) {\n        extra = [];\n\n        for (const [accessor, vecFactory] of attributeAccessors) {\n            extra.push(accessor.get(index, vecFactory()) as vec3);\n        }\n    }\n\n    return new Vertex(posAccessor.get(index, vec3.create()) as vec3, extra);\n}\n\nexport default function wleMeshToOctreeCSG(mesh: WL.Mesh, materialID?: number) {\n    // validate vertex count\n    const indexData = mesh.indexData;\n    const vertexCount = indexData === null ? mesh.vertexCount : indexData.length;\n\n    if (vertexCount % 3 !== 0) {\n        throw new Error(`Mesh has an invalid vertex count (${vertexCount}). Must be a multiple of 3`);\n    }\n\n    // prepare accessors\n    // TODO joint vertex attributes\n    const positions = mesh.attribute(WL.MeshAttribute.Position);\n    let attributeAccessors: AttributeAccessors = [];\n    const attributes = [];\n\n    const tangents = mesh.attribute(WL.MeshAttribute.Tangent);\n    if (tangents) {\n        attributeAccessors.push([tangents, () => vec4.create()]);\n        attributes.push(<MaterialAttribute>{\n            type: MaterialAttributeStandardType.Tangent,\n            valueType: MaterialAttributeValueType.Vec4,\n            transformable: MaterialAttributeTransform.Model,\n            flippable: false,\n        });\n    }\n\n    const normals = mesh.attribute(WL.MeshAttribute.Normal);\n    if (normals) {\n        attributeAccessors.push([normals, () => vec3.create()]);\n        attributes.push(<MaterialAttribute>{\n            type: MaterialAttributeStandardType.Normal,\n            valueType: MaterialAttributeValueType.Vec3,\n            transformable: MaterialAttributeTransform.Normal,\n            flippable: true,\n        });\n    }\n\n    const texCoords = mesh.attribute(WL.MeshAttribute.TextureCoordinate);\n    if (texCoords) {\n        attributeAccessors.push([texCoords, () => vec2.create()]);\n        attributes.push(<MaterialAttribute>{\n            type: MaterialAttributeStandardType.TextureCoordinate,\n            valueType: MaterialAttributeValueType.Vec2,\n            transformable: null,\n            flippable: false,\n        });\n    }\n\n    const colors = mesh.attribute(WL.MeshAttribute.Color);\n    if (colors) {\n        attributeAccessors.push([colors, () => vec4.create()]);\n        attributes.push(<MaterialAttribute>{\n            type: MaterialAttributeStandardType.Color,\n            valueType: MaterialAttributeValueType.Vec3,\n            transformable: null,\n            flippable: false,\n        });\n    }\n\n    if (!attributeAccessors.length) {\n        attributeAccessors = null;\n    }\n\n    // make octree\n    const materialIDNum = materialID ?? 0;\n    const octree = new OctreeCSG(new Map([[materialIDNum, attributes]]));\n\n    // convert\n    for (let i = 0; i < vertexCount;) {\n        let a, b, c;\n\n        if (indexData === null) {\n            a = makeVertex(i++, positions, attributeAccessors);\n            b = makeVertex(i++, positions, attributeAccessors);\n            c = makeVertex(i++, positions, attributeAccessors);\n        } else {\n            const ia = indexData[i++];\n            const ib = indexData[i++];\n            const ic = indexData[i++];\n            a = makeVertex(ia, positions, attributeAccessors);\n            b = makeVertex(ib, positions, attributeAccessors);\n            c = makeVertex(ic, positions, attributeAccessors);\n        }\n        const polygon = new Polygon([a, b, c], materialIDNum);\n        polygon.originalValid = true;\n        octree.addPolygon(polygon);\n    }\n\n    return octree;\n}", "// eslint-disable-next-line @typescript-eslint/triple-slash-reference\n/// <reference path=\"../../types/globals.d.ts\" />\n\nimport { MaterialAttributeStandardType } from 'octreecsg-ea';\n\nimport type { OctreeCSG, Vertex } from 'octreecsg-ea';\n\ntype AttributesMap = Map<number, WL.MeshAttributeAccessor>;\n\nfunction uploadVertex(vertex: Vertex, index: number, posAccessor: WL.MeshAttributeAccessor, wleAttributes: AttributesMap) {\n    posAccessor.set(index, vertex.pos as number[]);\n\n    if (vertex.extra) {\n        const extraCount = vertex.extra.length;\n\n        for (let i = 0; i < extraCount; i++) {\n            const accessor = wleAttributes.get(i);\n            if (accessor) {\n                accessor.set(index, vertex.extra[i]);\n            }\n        }\n    }\n}\n\nexport default function wleOctreeCSGToMesh(octree: OctreeCSG, materialMap: Readonly<Map<number, WL.Material>>): Map<WL.Material, WL.Mesh> {\n    // get polygons\n    const polygons = octree.getPolygons();\n\n    // count polygons for each material ID\n    const polygonCounts = new Map<number, number>();\n    for (const poly of polygons) {\n        const materialID = poly.shared;\n\n        if (!materialMap.has(materialID)) {\n            // ignore material if it's not present in the map\n            continue;\n        }\n\n        const count = polygonCounts.get(materialID) ?? 0;\n        polygonCounts.set(materialID, count + 1);\n    }\n\n    // make meshes for each material group\n    const groups = new Map<WL.Material, WL.Mesh>();\n    for (const [materialID, polygonCount] of polygonCounts) {\n        // make index buffer\n        const vertexCount = polygonCount * 3;\n        let indexType: WL.MeshIndexType, indexData: Uint8Array | Uint16Array | Uint32Array;\n        if (vertexCount <= 255) {\n            indexType = WL.MeshIndexType.UnsignedByte;\n            indexData = new Uint8Array(vertexCount);\n        } else if (vertexCount <= 65535) {\n            indexType = WL.MeshIndexType.UnsignedShort;\n            indexData = new Uint16Array(vertexCount);\n        } else {\n            indexType = WL.MeshIndexType.UnsignedInt;\n            indexData = new Uint32Array(vertexCount);\n        }\n\n        for (let i = 0; i < vertexCount; i++) {\n            indexData[i] = i;\n        }\n\n        // make mesh from index buffer\n        const mesh = new WL.Mesh({ vertexCount, indexType, indexData });\n        const material = materialMap.get(materialID) as WL.Material;\n        const position = mesh.attribute(WL.MeshAttribute.Position);\n        const wleAttributes: AttributesMap = new Map();\n        const attributes = octree.materials.get(materialID);\n\n        if (attributes) {\n            for (const [extraIndex, attributeType] of attributes.entries()) {\n                // TODO joints\n                switch (attributeType.type) {\n                    case MaterialAttributeStandardType.Tangent:\n                    {\n                        const tangents = mesh.attribute(WL.MeshAttribute.Tangent);\n                        if (tangents) {\n                            wleAttributes.set(extraIndex, tangents);\n                        } else {\n                            console.warn(`Could not create tangent mesh attribute accessor. Vertex property ignored`);\n                        }\n                        break;\n                    }\n                    case MaterialAttributeStandardType.Normal:\n                    {\n                        const normals = mesh.attribute(WL.MeshAttribute.Normal);\n                        if (normals) {\n                            wleAttributes.set(extraIndex, normals);\n                        } else {\n                            console.warn(`Could not create normal mesh attribute accessor. Vertex property ignored`);\n                        }\n                        break;\n                    }\n                    case MaterialAttributeStandardType.TextureCoordinate:\n                    {\n                        const texCoords = mesh.attribute(WL.MeshAttribute.TextureCoordinate);\n                        if (texCoords) {\n                            wleAttributes.set(extraIndex, texCoords);\n                        } else {\n                            console.warn(`Could not create texture coordinate mesh attribute accessor. Vertex property ignored`);\n                        }\n                        break;\n                    }\n                    case MaterialAttributeStandardType.Color:\n                    {\n                        const colors = mesh.attribute(WL.MeshAttribute.Color);\n                        if (colors) {\n                            wleAttributes.set(extraIndex, colors);\n                        } else {\n                            console.warn(`Could not create color mesh attribute accessor. Vertex property ignored`);\n                        }\n                        break;\n                    }\n                    default:\n                        console.warn(`Unsupported mesh attribute ID (${attributeType}) ignored`);\n                }\n            }\n        }\n\n        // populate mesh with polygons\n        let v = 0;\n        for (const poly of polygons) {\n            if (poly.shared === materialID) {\n                uploadVertex(poly.vertices[0], v++, position, wleAttributes);\n                uploadVertex(poly.vertices[1], v++, position, wleAttributes);\n                uploadVertex(poly.vertices[2], v++, position, wleAttributes);\n            }\n        }\n\n        groups.set(material, mesh);\n    }\n\n    return groups;\n}", "// eslint-disable-next-line @typescript-eslint/triple-slash-reference\n/// <reference path=\"../../types/globals.d.ts\" />\n\nimport wleOctreeCSGToMesh from './octree-to-mesh';\n\nimport type { OctreeCSG } from 'octreecsg-ea';\n\nexport default function wleAddOctreeCSGToObject(object: WL.Object, octree: OctreeCSG, materialMap: Readonly<Map<number, WL.Material>>): void {\n    const results = wleOctreeCSGToMesh(octree, materialMap);\n    for (const [material, mesh] of results.entries()) {\n        object.addComponent('mesh', { material, mesh });\n    }\n}"],
  "mappings": "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",
  "names": ["vec2", "vec3", "vec4", "OctreeCSG", "MaterialAttributeStandardType", "Polygon", "Vertex", "MaterialAttributeValueType", "MaterialAttributeTransform", "makeVertex", "index", "posAccessor", "attributeAccessors", "extra", "accessor", "vecFactory", "wleMeshToOctreeCSG", "mesh", "materialID", "indexData", "vertexCount", "positions", "attributes", "tangents", "normals", "texCoords", "colors", "materialIDNum", "octree", "i", "a", "b", "c", "ia", "ib", "ic", "polygon", "MaterialAttributeStandardType", "uploadVertex", "vertex", "index", "posAccessor", "wleAttributes", "extraCount", "i", "accessor", "wleOctreeCSGToMesh", "octree", "materialMap", "_a", "polygons", "polygonCounts", "poly", "materialID", "count", "groups", "polygonCount", "vertexCount", "indexType", "indexData", "mesh", "material", "position", "attributes", "extraIndex", "attributeType", "tangents", "normals", "texCoords", "colors", "v", "wleAddOctreeCSGToObject", "object", "octree", "materialMap", "results", "wleOctreeCSGToMesh", "material", "mesh"]
}
